# .github/workflows/check-compliance-release.yml

name: New Check for new ComplianceAsCode Release

on:
  schedule:
    - cron: '0 2 5 * *' # Runs on the 5th of every month
  workflow_dispatch: {}

env:
  TARGET_REPO: "ComplianceAsCode/content" 
  STATE_FILE: ".github/state/last_seen_release"
  ROLES_TO_COPY: "rhel9_stig rhel9_cis rhel9_cui"
  ROLES_DIR: "roles"
  GALAXY_NAMESPACE: "dperrone"
  GALAXY_NAME: "compliance_roles"

jobs:
  check-and-build:
    runs-on: ubuntu-latest

    permissions:
      contents: write 
      
    steps:
      - name: ðŸ”” Check out this repository
        uses: actions/checkout@v4

      - name: ðŸ“¡ Get latest release tag from ComplianceAsCode
        id: get_release
        run: |
          TAG=$(curl -s -H "Accept: application/vnd.github.v3+json" \
          "https://api.github.com/repos/${{ env.TARGET_REPO }}/releases/latest" | jq -r .tag_name)
          echo "Latest release on ${{ env.TARGET_REPO }} is: $TAG"
          echo "latest_tag=$TAG" >> $GITHUB_OUTPUT

      - name: ðŸ“– Get last processed tag from file
        id: get_last_tag
        run: |
          if [ -f "${{ env.STATE_FILE }}" ]; then
            echo "last_tag=$(cat ${{ env.STATE_FILE }})" >> $GITHUB_OUTPUT
          else
            echo "last_tag=''" >> $GITHUB_OUTPUT
          fi
        
      - name: ðŸš€ Compare, Build, and Generate Collection
        id: compare
        if: steps.get_release.outputs.latest_tag != steps.get_last_tag.outputs.last_tag
        run: |
          echo "âœ… New release found: ${{ steps.get_release.outputs.latest_tag }}"
          
          echo "Installing dependencies"
          sudo apt-get update
          sudo apt-get install -y git cmake make openscap-common openscap-scanner python3-yaml \
          python3-setuptools python3-pip python3-github libxml2-utils xsltproc

          echo "Cloning the ComplianceAsCode/content repository"
          git clone https://github.com/ComplianceAsCode/content
          cd content
          git checkout ${{ steps.get_release.outputs.latest_tag }}

          echo "Building the RHEL 9 roles
          ./build_product rhel9
          export PYTHONPATH=.
          utils/ansible_playbook_to_role.py out --build-playbooks-dir build/ansible

          echo "Change back into the repository root directory"
          cd .. 
          
          echo "Assemble the Ansible collection"
          mkdir -p ${{ env.ROLES_DIR }}
          rm -rf ${{ env.ROLES_DIR }}/*

          # Loop through the defined roles and copy to the roles directory
          echo "Copying new roles: ${{ env.ROLES_TO_COPY }}"
          for role in ${{ env.ROLES_TO_COPY }}; do
            if [ -d "content/out/$role" ]; then
              cp -r "content/out/$role" "${{ env.ROLES_DIR }}/"
            else
              echo "WARNING: Role '$role' not found in build output."
            fi
          done

          # Strip the 'v' from the tag name
          TAG="${{ steps.get_release.outputs.latest_tag }}"
          GALAXY_VERSION=${TAG#v}

          # Create the galaxy.yml file if it doesn't already exist
          cat <<EOF > galaxy.yml
          namespace: ${{ env.GALAXY_NAMESPACE }}
          name: ${{ env.GALAXY_NAME }}
          version: $GALAXY_VERSION 
          readme: README.md
          authors: [- Auto-generated by GitHub Actions]
          description: Ansible Collection for ComplianceAsCode roles.
          license: [Apache-2.0]
          tags: [security, compliance, stig, cis]
          dependencies: {}
          repository: ${{ github.server_url }}/${{ github.repository }}
          homepage: ${{ github.server_url }}/${{ github.repository }}
          issues: ${{ github.server_url }}/${{ github.repository }}/issues
          EOF

          # Create the meta directory for upload to Galaxy
          mkdir -p meta
          cat <<EOF > meta/runtime.yml
          ---
          requires_ansible: '>=2.9.10'
          EOF
          
          echo "Creating collection tarball..."
          TARBALL_NAME="${{ env.GALAXY_NAMESPACE }}-${{ env.GALAXY_NAME }}-${GALAXY_VERSION}.tar.gz"
          tar -czf $TARBALL_NAME ${{ env.ROLES_DIR }}/ galaxy.yml meta/
          
          # Output the tarball name for the release step
          echo "tarball_name=$TARBALL_NAME" >> $GITHUB_OUTPUT
          
          echo "Updating state file"
          mkdir -p $(dirname "${{ env.STATE_FILE }}")
          echo "${{ steps.get_release.outputs.latest_tag }}" > ${{ env.STATE_FILE }}
          echo "new_release_found=true" >> $GITHUB_OUTPUT
          
      - name: Commit Ansible Collection and state file
        if: steps.compare.outputs.new_release_found == 'true'
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "Update Ansible Collection to ${{ steps.get_release.outputs.latest_tag }}"
          file_pattern: "${{ env.ROLES_DIR }} galaxy.yml meta/ ${{ env.STATE_FILE }}"
  
      - name: Create GitHub Release
        if: steps.compare.outputs.new_release_found == 'true'
        uses: softprops/action-gh-release@v2
        with:
          # This creates a tag (e.g., v0.1.73) in your repo
          tag_name: ${{ steps.get_release.outputs.latest_tag }}
          
          # This is the title of the release
          name: "Ansible Collection ${{ steps.get_release.outputs.latest_tag }}"
          
          # This is the .tar.gz file to upload
          files: ${{ steps.compare.outputs.tarball_name }}
          
          # Optional: A brief description for the release body
          body: |
            Automated release of the Ansible Collection.
            Based on ComplianceAsCode release: ${{ steps.get_release.outputs.latest_tag }}
